## AQS

AQS 是用 CLH 队列实现的，即将暂时获取不到锁的线程加入到队列中。

CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。

AQS 使用一个volatile int 成员变量state来表示争抢的共享资源的同步状态，通过内置的 FIFO(CLH) 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

公平锁和非公平锁实现的区别，
* 在于公平锁只tryAquire一次，并且还要判断队列中是否有先于它的线程存在，
* 而非公平锁要tryAquire两次，并且不判断队列。

### 其他利用AQS

1. CountDownLatch 可以让某一个线程等待直到倒计时结束，再开始执行；也可以一个子线程执行结束后，然后countdown(),主线程调用await阻塞等待所有子线程执行完毕，再往下执行。
2. CyclicBarrier 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活

上面两个共享锁使用场景一样。
