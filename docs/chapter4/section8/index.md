## 线程池

线程池参数解析：

1. 最小线程数量
2. 最大线程数量
3. 任务队列（包括长度）
4. 空闲线程可存活时间（大于最小线程数量的其它线程）
5. 饱和策略（线程数量和任务队列都满了该怎么做）

submit()，线程池会返回一个 Future 类型的对象，Future 的get()方法会阻塞当前调用线程直到任务完成。

### 线程池大小确定

有一个简单并且适用面比较广的公式，N（CPU 核心数）：

* CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
* I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

如何判断是 CPU 密集任务还是 IO 密集任务？

* CPU 密集型：简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。
* IO 密集型：但凡涉及到网络读取，文件读取这类都是，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。
